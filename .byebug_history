c
quit
@words.map(&:lowest_point)
@words.map(&:lowest_point
@words.map(&:highest_point)
@words.map(&:leftmost_point)
@words.map(&:rightmost_point)
@words
@rightmost_point
@leftmost_point
@lowest_point
@highest_point
word
@words
c
@words
c
@words
c
@words
c
@words
word
n
self
@lowest_point
@rightmost_point
@leftmost_point
@highest_point
n
@lowest_point
@rightmost_point
@leftmost_point
@highest_point
@words
word
c
break Crossword::Board#place_word
s
q
puzzle.board.number_of_squares
puzzle.board.height
puzzle.board.width
q
puzzle.board.number_of_squares
puzzle.board.height
puzzle.board.width
puzzle.board
puzzle.clues
puzzle
quit
puzzle.board.get_words.map(&:rightmost_point)
puzzle.board.get_words.map(&:leftmost_point)
puzzle.board.get_words.map(&:highest_point)
puzzle.board.get_words.map(&:lowest_point)
puzzle.board.get_words
puzzle.board
puzzle.board.height
puzzle.board.number_of_squares
puzzle.board.height
puzzle.board.width
puzzle.board
puzzle
q
puzzle
c
quit
@words[1]
@words.first
@words.first.intersects?(@words[1])
@words.first.intersects?(@words.second)
@words
number_of_squares
s
n
s
n
s
n
current_board
n
s
n
s
quit
@words.each_with_index.map do |word, start_index| (start_index+1..words.count).map do |index| puts "Index: #{index}" || puts "Word: #{@words[index].inspect}" || word.intersects?(@words[index]) end end
@words.each_with_index.map do |word, start_index| (start_index+1..words.count).map do |index| puts "Index: #{index}"; puts "Word: #{@words[index].inspect}"; word.intersects?(@words[index]) end end
@words.each_with_index.map do |word, start_index| (start_index+1..words.count).map do |index| word.intersects?(@words[index]) end end
break Crossword::Board::Word#intersects?
@words.each_with_index.map do |word, start_index| (start_index+1..words.count).map do |index| 1 end end
words.count
@words.each_with_index.map do |word, start_index| (start_index+1..words.count).map do |index| word.intersects?(@words[index]) end end
word
@words.each_with_index.map do |word, start_index| (start_index+1..words.count).map do |index| word.intersects?(@words[index]) end end
@words.each_with_index do |word, start_index|
n
s
n
s
words_to_add.reduce(&:<<).length
words_to_add.reduce(&:<<)
words_to_add
c
break Crossword::Board#minimum_projected_board_size
q
n
start_index
intersections
n
s
n
s
start_index
word
s
n
@words
s
number_of_squares
(words_to_add.map(&:length).reduce(&:+) || 0)/2
words_to_add.map(&:length).reduce(&:+)
words_to_add.map(&:length)
words_to_add
words_to_add.map(&:length))
words_to_add.reduce(&:<<)
number_of_squares
s
@board.minimum_projected_board_size(@unplaced_words)
@board
s
possible_boards
n
BoardWrapper.new(@board.clone.place_word(word, location[:x], location[:y], location[:direction]), @all_words).complete?
BoardWrapper.new(@board.clone.place_word(word, location[:x], location[:y], location[:direction]), @all_words)
@board.clone.place_word(word, location[:x], location[:y], location[:direction])
@board.clone
location
s
locations_for_word
n
s
n
s
n
c
break Crossword::BoardWrapper#generate_possible_sub_boards
q
n
s
c
q
c
n
locations_for_word
n
s
n
s
n
s
c
quit
@words.first.conflicts_with?(word, locations.first)
@words.first.conflicts_with?(word.value, locations.first)
@words
locations
word
n
s
@board.send(:find_intersections, word)
@board.get_words
@board.send(:find_intersections, word)
@board.find_possible_locations(word)
@unplaced_words
generated_boards
word
s
n
s
@unplaced_words
s
n
current_board.get_words
current_board.words
current_board
n
s
c
quit
words.first.value.to_s.chars
words.map do |board_word| board_word.to_s.chars end
words.each do |board_word| board_word.to_s.chars
words.each do |board_word|
intersecting_indices = []
letters = Set.new(word.to_s.chars)
word = 'try'
words = board.get_words
board.get_words.first
board.get_words
board
quit
def board.get_words; return @words; end
def board.get_words return  @words end
def board.get_words { @words } end
def board.get_words
board
board.send('@words')
board.words
@words
intersecting_indices = []
letters = Set.new(word.to_s.chars)
word = 'try'
board.send('find_intersections', 'try')
board
quit
@board
n
word
eliminate_bad_locations(word, find_intersections(word))
find_intersections(word)
word
s
@board
locations_for_word = @board.find_possible_locations(word)
word = @unplaced_words.first
@unplaced_words.each_with_object([]) do |word, generated_boards|
s
n
s
n
@unplaced_words
s
current_board.generate_possible_sub_boards
current_board
n
current_board.number_of_squares < best_solution_so_far
n
current_board.number_of_squares < best_solution_so_far
best_solution_so_far
current_board.number_of_squares
current_board.complete?
current_board
n
best_board
possible_boards
n
initial_board_possibilities.first.board.unplaced_words
initial_board_possibilities.first.board
initial_board_possibilities.first.words.first
initial_board_possibilities.first.words
initial_board_possibilities.first
initial_board_possibilities.count
initial_board_possibilities
n
words
s
